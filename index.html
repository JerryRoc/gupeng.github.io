<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Everything About Data Science.">
<meta name="keywords" content="data science, machine learning, data mining">
<meta property="og:type" content="website">
<meta property="og:title" content="Peng&#39;s Blog">
<meta property="og:url" content="https://jerryroc.github.io/index.html">
<meta property="og:site_name" content="Peng&#39;s Blog">
<meta property="og:description" content="Everything About Data Science.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Peng&#39;s Blog">
<meta name="twitter:description" content="Everything About Data Science.">





  
  
  <link rel="canonical" href="https://jerryroc.github.io/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Peng's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Peng's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jerryroc.github.io/2019/05/21/R-Visualization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="GuPeng">
      <meta itemprop="description" content="Everything About Data Science.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Peng's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/21/R-Visualization/" class="post-title-link" itemprop="url">R语言：可视化概览</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-21 17:22:30 / Modified: 18:05:38" itemprop="dateCreated datePublished" datetime="2019-05-21T17:22:30+08:00">2019-05-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/AnalyzeAnython/" itemprop="url" rel="index"><span itemprop="name">AnalyzeAnython</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>编者按：统计学家最爱的 R 与 “A graph is worth a thousand words” 的可视化工具。本期博文，就让我们了解一下 R 语言如何进行数据可视化。</p>
</blockquote>
<p>“The simple graph has brought more information to the data analyst’s mind than any other device.” — John Tukey</p>
<p>数据可视化在学术界和工业界都有广泛的应用——除了许多论文里的实验数据图表外，企业的KPI报表、股市的K线图、制造业的传感器数据监测、航空公司的上客监控，包括每年大家喜（ji）闻（si）乐（ren）见（le）的春运大数据，都是可视化的应用。<strong>数据可视化可以让我们更直观地从数据中获取信息</strong>。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/baidu_map_travel.png" alt="百度地图春运出行仪表盘（http://qianxi.baidu.com） – 2019五一小长假出行数据" title="百度地图春运出行仪表盘（http://qianxi.baidu.com） – 2019五一小长假出行数据"></p>
<p>英国新闻巨头BBC有一个数据新闻团队（Data Journalism），专注于“从大量数据中发现值得注意的事实”。近期，该团队分享了他们基于R开发的工具包bbplot，使大家能够简单方便地绘制出达到出版标准的图表。专业化的绘图工具正在被越来越多的行业所使用。本期博文，就让我们了解一下R语言如何进行数据可视化。</p>
<h1 id="R-的绘图系统"><a href="#R-的绘图系统" class="headerlink" title="R 的绘图系统"></a>R 的绘图系统</h1><p>R语言有两大绘图系统：基础绘图系统和Grid绘图系统，两者相互独立。基础绘图系统直接在图形设备上画图；而Grid系统将界面分成矩形区域（viewport），每个区域有自己独立的坐标体系，并且相互可以嵌套，使得Grid系统可以画出更复杂的图形。</p>
<p>用过R的朋友们知道，R的功能是通过一个个库（package）——也就是我们常说的工具包实现的。基础绘图系统依赖于graphics包。基于Grid系统的包有grid，lattice，ggplot2等。grid包仅提供低级的绘图功能（如点、线等），并不能画出完整的图形。更高级的图形是两个主流绘图包lattice和ggplot2来实现。</p>
<p>让我们来关注最常用的三个包：graphics， lattice、ggplot2。</p>
<h2 id="graphics包"><a href="#graphics包" class="headerlink" title="graphics包"></a>graphics包</h2><p>基础绘图包graphics，在安装R时默认安装，启动R时默认加载。它囊括了常用的标准统计图形，如条形图，饼图，直方图，箱线图，散点图等。在R里运行：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo(graphics)</span><br></pre></td></tr></table></figure>
<p>会给出一些常用图形的样例（如下图），及生成这些图形的代码。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/graphics.png&quot;graphics&quot;" alt="graphics"></p>
<h2 id="lattice包"><a href="#lattice包" class="headerlink" title="lattice包"></a>lattice包</h2><p>在使用之前，需要先加载lattice包。lattice包提供了大量新的绘图类型、默认颜色、图形排版等优化。同时，它还支持“条件多框图”—— 如下图，在不同月份（Month），观察臭氧浓度（Ozone）与气温（Temp）之间的关系。这里，“月份”就是我们所说的条件，条件多框图可以让我们更清楚地看到Ozone与Temp的关系是否受月份的影响而发生变化。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(lattice)</span><br><span class="line">xyplot(Temp ~ Ozone |factor(Month),</span><br><span class="line">	data = airquality,</span><br><span class="line">	main=<span class="string">"Temp(F) vs Ozone(ppb) by Month"</span>,</span><br><span class="line">	layout=c(<span class="number">5</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/lattice.png&quot;lattice&quot;" alt="lattice"></p>
<h2 id="ggplot2包"><a href="#ggplot2包" class="headerlink" title="ggplot2包"></a>ggplot2包</h2><p>ggplot2由Hadley Wickham根据Grammar of Graphics（图形的语法）中提出的理论而开发。它将绘图视为一种映射，即从数学空间映射到图形元素空间。它的绘图方式类似于我们平时生活中画图，先创建一个画布，然后一层层往上叠加信息。ggplot2是R中最常用到同时也是功能最强大的绘图包（Python中也有了ggplot2的实现——plotnine，你只需要对R语言中的ggplot2代码稍作修改，就能直接在Python中运行）。</p>
<p>我们用ggplot2中自带的数据diamonds为例来描述绘图过程：绘制钻石克拉数（carat）与价格（price）的关系，同时将纯度（clarity）作为颜色变量。在代码中，carat, price, clarity分别被映射到了x轴，轴y及color。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line">ggplot(data=diamonds, mappings=aes(x=carat, y=price))+</span><br><span class="line">	geom_point(aes(color=clarity))</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/ggplot2_1.png" alt="ggplot2_1" title="ggplot2_1"></p>
<p>如果我们想在图中增添统计变换，如两变量关系的平滑曲线，仅需增加一行代码</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ggplot(data=diamonds, mappings=aes(x=carat, y=price))+</span><br><span class="line">	geom_point(aes(color=clarity))+stat_smooth()</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/ggplot2_2.png" alt="ggplot2_2" title="ggplot2_2"></p>
<p>同样的，如果我们想分析在不同切工（cut）下克拉数与价格的关系（类似于lattice中的条件多框图），也是一行代码的工作量</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ggplot(data=diamonds, mappings=aes(x=carat, y=price))+</span><br><span class="line">	geom_point(aes(color=clarity))+</span><br><span class="line">	stat_smooth()+facet_wrap(~cut)</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/ggplot2_3.png" alt="ggplot2_3" title="ggplot2_3"></p>
<p>ggplo2的基本概念有：</p>
<ul>
<li>数据(data)和映射(mapping) </li>
<li>几何对象(geometric)</li>
<li>标度(scale)</li>
<li>统计变换(statistics)</li>
<li>坐标系统(coordinate) </li>
<li>分面(facet)</li>
</ul>
<h1 id="R-Graph-Gallery"><a href="#R-Graph-Gallery" class="headerlink" title="R Graph Gallery"></a>R Graph Gallery</h1><p>除了上述提到的三个常用绘图包，R还有很多其他图形绘制的工具，如绘制3D图形的plot3d，rgl，绘制地图的ggmap，leaflet，交互式可视化plotly等等。在这里，我们介绍一个神奇的网站 THE R GRAPH GALLERY (<a href="https://www.r-graph-gallery.com)。这个网站为我们提供了平时常用的8大类46种共计数146个（日期：2019-05-13）可视化样例及代码，及他们使用的工具包。" target="_blank" rel="noopener">https://www.r-graph-gallery.com)。这个网站为我们提供了平时常用的8大类46种共计数146个（日期：2019-05-13）可视化样例及代码，及他们使用的工具包。</a></p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/R_gallery_1.png" alt="R_gallery_1" title="R_gallery_1"><br><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/R_gallery_2.png" alt="R_gallery_2" title="R_gallery_2"><br><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/R_gallery_3.png" alt="R_gallery_3" title="R_gallery_3"><br><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/R_gallery_4.png" alt="R_gallery_4" title="R_gallery_4"></p>
<p>例如，点击Sankey diagram（倒数第二行最后一个）的图标，会进入如下的界面。可以看到NetworkD3这个包能用来绘制Sankey图。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/sankey.png" alt="sankey" title="sankey"></p>
<p>点击图形下的链接，网站会给出该图形的详细信息及实现的代码</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/code_for_sankey.png" alt="code_for_sankey" title="code_for_sankey"></p>
<p>THE R GRAPH GALLERY 网站不仅提供各类统计图形的R的实现方式，同时也在收录相对应的Python的实现，是学习可视化非常好的资源。</p>
<h1 id="R-Shiny"><a href="#R-Shiny" class="headerlink" title="R Shiny"></a>R Shiny</h1><p>在我们的分析工作中，有时不仅要展示模型结果，还需要把分析历程展示给听众；同时，听众也希望能够参与到分析探索中来。这就需要我们将不同部分的分析 —— 如数据探索，模型构建及评估的过程整合到一起，同时增添可交互性。</p>
<p>Shiny （<a href="http://shiny.rstudio.com/）是由RStudio开发的一个开源的" target="_blank" rel="noopener">http://shiny.rstudio.com/）是由RStudio开发的一个开源的</a> R 包，它为使用 R 构建 Web 应用提供了一个有力的 Web 框架。使用Shiny，我们可以用R语言轻松开发交互式web应用。在Shiny的官网上给出了一些App的应用案例：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/R_Shiny.png" alt="R_Shiny" title="R_Shiny"></p>
<p>我们通过官网上Kmeans example的例子（Demo）来看一看Shiny App的基本功能。这个例子中用的是R自带的鸢尾花（iris）数据，用过R（或者Python）的朋友应该对这个数据非常熟悉。数据里包含了花萼长度(Sepal.Length)，花萼宽度(Sepal.Width)，花瓣长度(Pepal. Length)，花瓣宽度(Pepal.Width)及花的品种(Species)信息。</p>
<p>在Demo中假设品种未知，通过其它变量将鸢尾花样本分群。默认选项是将样本按照Sepal.Length和 Sepal.Width分成3群。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/iris_1.png" alt="iris_1" title="iris_1"></p>
<p>通过Demo左侧的工具栏，我们可以选择不同的分群变量（Pepal. Length，Pepal.Width）及分群个数（2），来观察不同的分群效果</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190521%20R%20Visualization/iris_2.png" alt="iris_2" title="iris_2"></p>
<p>实现这样一个Shiny App的需要两部分脚本：用户交互（shinyUI）及服务器（shinyServer）脚本。</p>
<ul>
<li><p>shinyUI部分控制页面的布置和展示。一方面，在这里可以定义一系列的小工具，如滑动条（sliderInput），选项卡（radioButtons），输入框（numericInput）等来接收用户传入的参数，储存在input变量里。另一方面，它接收shinyServer传来的output变量，并根据用户的定义把它展示在前端。</p>
</li>
<li><p>shinyServer生成所要展示的结果。它从shinyUI读取input变量，将其作为参数进行模型计算或图形绘制，然后将结果储存在output变量里，传给shinyUI前端。</p>
</li>
</ul>
<p>总结来说，shinyUI用于根据用户的输入生成input，同时展示output结果，shinyServer接收input参数，计算生成output。有兴趣的朋友可以在Shiny的官网找到详细的培训教程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本文，我们介绍了一些R的常用绘图包以及学习资源：graphics通常用于快速基本的分析绘图，个性化的图形建议使用ggplot2来实现。R Graph Gallery从需求出发，归纳总结了各类图形的使用案例。而Shiny整合前面的所有，生成可交互式的dashboard。这些都是工具，而作为数据科学家，我们要做的就是利用这些工具让数据“说话”。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li>BBC Visual and Data Journalism cookbook for R graphics  <a href="https://bbc.github.io/rcookbook/" target="_blank" rel="noopener">https://bbc.github.io/rcookbook/</a></li>
<li>Paul Murrell（2011）<em>R Graphics Second Edition</em></li>
<li>ggplot2 Reference <a href="https://ggplot2.tidyverse.org/reference/" target="_blank" rel="noopener">https://ggplot2.tidyverse.org/reference/</a></li>
<li>THE R GRAPH GALLERY <a href="https://www.r-graph-gallery.com" target="_blank" rel="noopener">https://www.r-graph-gallery.com</a></li>
<li>Shiny <a href="http://shiny.rstudio.com" target="_blank" rel="noopener">http://shiny.rstudio.com</a></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jerryroc.github.io/2019/05/04/Introduction-to-Graph-Algorithms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="GuPeng">
      <meta itemprop="description" content="Everything About Data Science.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Peng's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/04/Introduction-to-Graph-Algorithms/" class="post-title-link" itemprop="url">图算法：概览</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-04 14:41:21" itemprop="dateCreated datePublished" datetime="2019-05-04T14:41:21+08:00">2019-05-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-05-21 17:59:19" itemprop="dateModified" datetime="2019-05-21T17:59:19+08:00">2019-05-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇<a href="https://jerryroc.github.io/2019/04/21/Introduction-to-Graph-Database/">博文</a>中，我们已经对图数据库基础作了分享，介绍了图和图数据库的基本概念，今天我们的主题是：图算法。本篇博文的主要内容来源于 O’Reilly 系列的《<a href="https://www.oreilly.com/library/view/graph-algorithms/9781492047674/" target="_blank" rel="noopener">Graph Algorithms</a>》，作者 Amy E. Hodler &amp; Mark Needham。你肯定没有读过这本书，因为这本书的发布日期是2019年5月。本文会覆盖该书的大部分内容，读完这篇，你能够了解图算法的基本概念。关于此书，作为市面上为数不多的面向数据科学应用的图算法书籍，写的比较全面系统和易懂。当然，书在细节上的提高空间还有很多。今天内容很多，坐稳~</p>
<h1 id="图算法-amp-图分析"><a href="#图算法-amp-图分析" class="headerlink" title="图算法 &amp; 图分析"></a>图算法 &amp; 图分析</h1><p><strong>图分析</strong>使用基于图的方法来分析连接的数据。我们可以：查询图数据，使用基本统计信息，可视化地探索图、展示图，或者将图信息预处理后合并到机器学习任务中。图的查询通常用于局部数据分析，而图计算通常涉及整张图和迭代分析。</p>
<p><strong>图算法</strong>是图分析的工具之一。图算法提供了一种最有效的分析连接数据的方法，它们描述了如何处理图以发现一些定性或者定量的结论。图算法基于图论，利用节点之间的关系来推断复杂系统的结构和变化。我们可以使用这些算法来发现隐藏的信息，验证业务假设，并对行为进行预测。</p>
<p>图分析和图算法具有广泛的应用潜力：从防止欺诈，优化呼叫路由，到预测流感的传播。下图是 Martin Grandjean 创建的航线网络图，这幅图清楚地展示了航空运输集群高度连接的结构，帮助我们了解航空运力如何流动。航线网络采用典型的辐射式结构（hub-and-spoke structure），这样的结构在有限运力的前提下，增大了航线的网络的始发-到达对（OD Pair），然而却也带来了系统级联延迟的可能。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Transportation_clusters.png" alt="Air Transportation Networks " title="Air Transportation Networks "></p>
<h1 id="图基础知识"><a href="#图基础知识" class="headerlink" title="图基础知识"></a>图基础知识</h1><p>我们已经在前一篇<a href="https://jerryroc.github.io/2019/04/21/Introduction-to-Graph-Database/">博文</a>中介绍了属性图的概念。我们已经知道了节点、关系、属性（Property）、标签等概念。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Labeled_property_graph_model.png" alt="Labeled Property Graph Model" title="Labeled Property Graph Model"></p>
<p><strong>子图（Subgraph）</strong>是一张图的一部分。当我们需要对图中的特定节点，特定关系，或者特定标签或者属性进行特定分析时，子图就会很有用。</p>
<p><strong>路径（Path）</strong>是一组节点及他们的关系的集合。以上图为例，“Dan” 开过型号为 “Volvo V70” 的车，这辆车是属于 “Ann” 的。那么节点 “Dan” “Ann” “Car”和关系 “Drives” “Owns” 组成了一个简单的路径。</p>
<p>我们在介绍图算法前，先梳理一下图的不同属性（Attribute）。</p>
<h2 id="连通图与非连通图"><a href="#连通图与非连通图" class="headerlink" title="连通图与非连通图"></a>连通图与非连通图</h2><p><strong>连通图（Connected Graphs）</strong>指图内任意两个节点间，总能找到一条路径连接它们，否则，为<strong>非连通图（Disconnected Graphs）</strong>。也就是说，如果图中包含岛（Island）,则是非连通图。如果岛内的节点都是连通的，这些岛就被成为一个部件（Component，有时也叫 Cluster）。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Connected_versus_Disconnected_Graphs.png" alt="Connected versus Disconnected Graphs" title="Connected versus Disconnected Graphs"></p>
<p>有些图算法在非连通图上可能产生无法预见的错误。如果我们发现了未预见的结果，可以首先检查图的结构是否连通。</p>
<h2 id="未加权图与加权图"><a href="#未加权图与加权图" class="headerlink" title="未加权图与加权图"></a>未加权图与加权图</h2><p>未加权图（Unweighted Graphs）的节点和边上均没有权重。对于加权图（Weighted Graphs），所加权重可以代表：成本、时间、距离、容量、甚至是指定域的优先级。下图给出了示意图。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Unweighted_Graphs_versus_Weighted_Graphs.png" alt="Unweighted Graphs versus Weighted Graphs" title="Unweighted Graphs versus Weighted Graphs"></p>
<p>基本的图算法可以通过处理权重来代表关系的强度。许多算法通过计算指标，用作后续算法的权重。也有些算法通过更新权重值，来查找累计总数、最小值或最优化结果。</p>
<p>关于加权图的一个典型用途是路径寻找算法。这些算法支持我们手机上的地图应用程序，并计算位置之间最短/最便宜/最快的运输路线。例如，下图使用了两种不同的方法来计算最短路线。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/The_shortest_paths_can_vary_for_unweighted_and_weighted_graph.png" alt="The shortest paths can vary for unweighted and weighted graph" title="The shortest paths can vary for unweighted and weighted graph"></p>
<p>如果没有权重，计算最短路径时，实则在计算关系（Relation，也称 Hop）的数量。那么在上图左边，我们找到 A 和 E 之间的最短距离为 2，经过 D 点。如果像上图右边所示，边被赋予了权重，用以代表节点之间的物理距离（单位：KM）。那么我们可以找到 A 和 E 之间的最短距离是 50 KM，需要经过 C 和 D 两个点。而此时，在未加权图中计算的最短路径 <code>A-D-E</code> 距离为 70 KM，比我们找到的路径 <code>A-C-D-E</code> 距离远。</p>
<h2 id="有向图与无向图"><a href="#有向图与无向图" class="headerlink" title="有向图与无向图"></a>有向图与无向图</h2><p>在无向图（Undirected Graphs）中，节点的关系被认为是双向的（bi-directional），例如朋友关系。而在有向图（Directed Graphs）中，节点的关系可以指定方向。边如果指向了一个节点，我们称为 in-link，边如果从一个节点出发，我们称为 out-link。</p>
<p>边的方向加入了更多维度的信息，同样关系的边，却包含不同的方向，则代表了不同的语义信息。如下图所示，有向图绘制了一个简单的同学网络，边的方向代表着 “喜欢”。那么从图中，我们可以知道，同学中 “最受欢迎的” 的人是 “A” 和 “C”。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Undirected_Graphs_versus_Directed_Graphs.png" alt="Undirected Graphs versus Directed Graphs" title="Undirected Graphs versus Directed Graphs"></p>
<p>我们还可以用道路网络帮我们理解为什么需要有向图和无向图。例如，高速公路一般都是双向的，我们使用无向图即可。但是，在城市内部，经常会有单向车道，我们必须使用有向图。</p>
<h2 id="非循环图和循环图"><a href="#非循环图和循环图" class="headerlink" title="非循环图和循环图"></a>非循环图和循环图</h2><p>图论中，循环指一些特殊的路径，它们的起点和终点是同一个节点。在非循环图（Acyclic Graph）中，不存在循环路径，相反则为循环图（Cyclic Graphs）。如下图所示，有向图和无向图都可能包含循环，所不同的是，有向图的路径必须遵循边的方向。图中的 Graph 1 是一个典型的 DAG（Directed Acyclic Graph，有向无循环图），并且 DAG 通常有叶子节点（leaf node，也称 dead node）。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Acyclic_Graphs_versus_Cyclic_Graphs.png" alt="Acyclic Graphs versus Cyclic Graphs" title="Acyclic Graphs versus Cyclic Graphs"></p>
<p>Graph 1 和 Graph 2 是无循环的，因为我们在不重复任何一条边的情况下，无法从任何一个点出发，再回到它。Graph 3 中有一个简单的循环 <code>A-D-C-A</code>。而 Graph 4 中，我们可以发现多个循环：<code>B-F-C-D-A-C-B</code>，<code>C-B-F-C</code> 等等。</p>
<p>循环在图中非常常见。有时，我们为了提高处理效率，会将循环图转化为非循环图（通过剪除一些关系）。DAG 在调度、版本控制等问题中十分常见。实际上，我们在数学或者计算机科学中经常遇见的树（Tree）就是一个典型的 DAG，只是对于树来说，只能拥有一个 Parent，而 DAG 没有这个限制。</p>
<h1 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h1><p>我们关注三类核心的图算法：路径搜索（Pathfinding and Search）、中心性计算（Centrality Computation）和社群发现（Community Detection）。</p>
<h2 id="路径搜索算法"><a href="#路径搜索算法" class="headerlink" title="路径搜索算法"></a>路径搜索算法</h2><p>图搜索算法（Pathfinding and Search Algorithms）探索一个图，用于一般发现或显式搜索。这些算法通过从图中找到很多路径，但并不期望这些路径是计算最优的（例如最短的，或者拥有最小的权重和）。图搜索算法包括广度优先搜索和深度优先搜索，它们是遍历图的基础，并且通常是许多其他类型分析的第一步。</p>
<p>路径搜索（Pathfinding）算法建立在图搜索算法的基础上，并探索节点之间的路径。这些路径从一个节点开始，遍历关系，直到到达目的地。路径搜索算法识别最优路径，用于物流规划，最低成本呼叫或者叫IP路由问题，以及游戏模拟等。</p>
<p>下图是路径搜索类算法的分类：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Pathfinding_and_Search_Algorithms.png" alt="Pathfinding and Search Algorithms" title="Pathfinding and Search Algorithms"></p>
<h3 id="DFS-amp-BFS"><a href="#DFS-amp-BFS" class="headerlink" title="DFS &amp; BFS"></a>DFS &amp; BFS</h3><p>图算法中最基础的两个遍历算法：广度优先搜索（Breadth First Search，简称 BFS）和深度优先搜索（Depth First Search，简称 DFS）。BFS 从选定的节点出发，<strong>优先访问所有一度关系的节点</strong>之后再继续访问二度关系节点，以此类推。DFS 从选定的节点出发，选择任一邻居之后，尽可能的沿着边遍历下去，知道不能前进之后再回溯。</p>
<p>下面是两张同样的图，分别采用 BFS 和 DFS 进行图的遍历，图上节点的数字标识这遍历顺序。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Breadth_First_Search.png" alt="Breadth First Search" title="Breadth First Search"></p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Depth_First_Search.png" alt="Depth First Search" title="Depth First Search"></p>
<p>对于我们数据科学的角色来说，我们很少真正需要使用 BFS 和 DFS。这两个图搜索算法更多地作为底层算法支持其他图算法。例如，最短路径问题和 Closeness Centrality （在后文会有介绍）都使用了 BFS 算法；而 DFS 可以用于模拟场景中的可能路径，因为按照 DFS 访问节点的顺序，我们总能在两个节点之间找到相应的路径。感兴趣的话，可以猜一猜，后文介绍的算法是否使用了图搜索算法，并且分别使用了 DFS 还是 BFS。</p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p><strong>最短路径（Shortest Paths）</strong>算法计算给定的两个节点之间最短（最小权重和）的路径。算法能够实时地交互和给出结果，可以给出关系传播的度数（degree），可以快速给出两点之间的最短距离，可以计算两点之间成本最低的路线等等。例如：</p>
<ul>
<li>导航：谷歌、百度、高德地图均提供了导航功能，它们就使用了最短路径算法（或者非常接近的变种）；</li>
<li>社交网络关系：当我们在 LinkedIn、人人（暴露年龄了）等社交平台上查看某人的简介时，平台会展示你们之间有多少共同好友，并列出你们之间的关系。</li>
</ul>
<p>最常见的最短路径算法来自于 1956 年的 Edsger Dijkstra。Dijkstra 的算法首先选择与起点相连的最小权重的节点，也就是 “最临近的” 节点，然后比较 <code>起点到第二临近的节点的权重</code> 与 <code>最临近节点的下一个最临近节点的累计权重和</code> 从而决定下一步该如何行走。可以想象，算法记录的<code>累计权重和</code> 如同地理的 “等高线” 一样，在图上以 “波” 的形式传播，直到到达目的地节点。</p>
<p>最短路径算法有两个常用的变种：A<em> （可以念作 A Star）algorithm和 Yen’s K-Shortest Paths。A</em> algorithm 通过提供的额外信息，优化算法下一步探索的方向。Yen’s K-Shortest Paths 不但给出最短路径结果，同时给出了最好的 K 条路径。</p>
<p><strong>所有节点对最短路径（All Pairs Shortest Path）</strong>也是一个常用的最短路径算法，计算所有节点对的最短路径。相比较一个一个调用单个的最短路径算法，All Pairs Shortest Path 算法会更快。算法并行计算多个节点的信息，并且这些信息在计算中可以被重用。</p>
<p>本文不打算再深入了，下图是从A节点开始的计算过程，看懂这张图，你就明白了。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/All_Pairs_Shortest_Paths.png" alt="All Pairs Shortest Paths" title="All Pairs Shortest Paths"></p>
<p>All Pairs Shortest Path 算法通常用于，当最短路径受限或者变成了非最优时，如何寻找替代线路。其实算法非常常用：</p>
<ul>
<li>优化城市设施的位置和货物的分配：例如确定运输网格中不同路段上预期的交通负荷，例如快递线路设计，从而保证运输对突发事件的应对；</li>
<li>作为数据中心设计算法的一部分：查找具有最大带宽和最小延迟的网络。</li>
</ul>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>最小生成树（Minimum Spanning Tree）算法从一个给定的节点开始，查找其所有可到达的节点，以及将节点与最小可能权重连接在一起，行成的一组关系。它以最小的权重从访问过的节点遍历到下一个未访问的节点，避免了循环。</p>
<p>最常用的最小生成树算法来自于 1957 年的 Prim 算法。Prim 算法与Dijkstra 的最短路径类似，所不同的是， Prim 算法每次寻找最小权重访问到下一个节点，而不是累计权重和。并且，Prim 算法允许边的权重为负。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Minimum_Spanning_Tree_algorithm.png" alt="Minimum Spanning Tree algorithm" title="Minimum Spanning Tree algorithm"></p>
<p>上图是最小生成树算法的步骤分解，算法最终用最小的权重将图进行了遍历，并且在遍历的过程中，不产生环。</p>
<p>算法可以用于优化连接系统（如水管和电路设计）的路径。它还用于近似一些计算时间未知的问题，如旅行商问题。虽然该算法不一定总能找到绝对最优解，但它使得复杂度极高和计算密集度极大的分析变得更加可能。例如：</p>
<ul>
<li>旅行计划：尽可能降低探索一个国家的旅行成本；</li>
<li>追踪流感传播的历史：有人使用最小生成树模型对丙型肝炎病毒感染的医院暴发进行分子流行病学调查</li>
</ul>
<h3 id="随机游走"><a href="#随机游走" class="headerlink" title="随机游走"></a>随机游走</h3><p>随机游走（Random Walk）算法从图上获得一条随机的路径。随机游走算法从一个节点开始，随机沿着一条边正向或者反向寻找到它的邻居，以此类推，直到达到设置的路径长度。这个过程有点像是一个醉汉在城市闲逛，他可能知道自己大致要去哪儿，但是路径可能极其“迂回”，毕竟，他也无法控制自己~</p>
<p>随机游走算法一般用于随机生成一组相关的节点数据，作为后续数据处理或者其他算法使用。例如：</p>
<ul>
<li>作为 <strong>node2vec</strong> 和 <strong>graph2vec</strong> 算法的一部分，这些算法可以用于节点向量的生成，从而作为后续深度学习模型的输入；这一点对于了解 NLP （自然语言处理）的朋友来说并不难理解，词是句子的一部分，我们可以通过词的组合（语料）来训练词向量。那么，我们同样可以通过节点的组合（Random Walk）来训练节点向量。这些向量可以表征词或者节点的含义，并且能够做数值计算。这一块的应用很有意思，我们会找机会来详细介绍；</li>
<li>作为 <strong>Walktrap</strong> 和 <strong>Infomap</strong> 算法的一部分，用于社群发现。如果随机游走总是返回同一组节点，表明这些节点可能在同一个社群；</li>
<li>其他机器学习模型的一部分，用于随机产生相关联的节点数据。</li>
</ul>
<h2 id="中心性算法"><a href="#中心性算法" class="headerlink" title="中心性算法"></a>中心性算法</h2><p>中心性算法（Centrality Algorithms）用于识别图中特定节点的角色及其对网络的影响。中心性算法能够帮助我们识别最重要的节点，帮助我们了解组动态，例如可信度、可访问性、事物传播的速度以及组与组之间的连接。尽管这些算法中有许多是为社会网络分析而发明的，但它们已经在许多行业和领域中得到了应用。</p>
<p>下图罗列了我们所有需要了解的中心性算法指标。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Centrality_Algorithms.png" alt="Centrality Algorithms" title="Centrality Algorithms"></p>
<h3 id="Degree-Centrality"><a href="#Degree-Centrality" class="headerlink" title="Degree Centrality"></a>Degree Centrality</h3><p>Degree Centrality （度中心性，以度作为标准的中心性指标）可能是整篇博文最简单的 “算法” 了。Degree 统计了一个节点直接相连的边的数量，包括出度和入度。Degree 可以简单理解为一个节点的访问机会的大小。例如，在一个社交网络中，一个拥有更多 degree 的人（节点）更容易与人发生直接接触，也更容易获得流感。</p>
<p>一个网络的平均度（average degree），是边的数量除以节点的数量。当然，平均度很容易被一些具有极大度的节点 “带跑偏” （skewed）。所以，度的分布（degree distribution）可能是表征网络特征的更好指标。</p>
<p>如果你希望通过出度入度来评价节点的中心性，就可以使用 degree centrality。度中心性在关注直接连通时具有很好的效果。应用场景例如，区分在线拍卖的合法用户和欺诈者，欺诈者由于尝尝人为太高拍卖价格，拥有更高的加权中心性（weighted centrality）。</p>
<h3 id="Closeness-Centrality"><a href="#Closeness-Centrality" class="headerlink" title="Closeness Centrality"></a>Closeness Centrality</h3><p><strong>Closeness Centrality（紧密性中心性）</strong>是一种检测能够通过子图有效传播信息的节点的方法。紧密性中心性计量一个节点到所有其他节点的紧密性（距离的倒数），一个拥有高紧密性中心性的节点拥有着到所有其他节点的距离最小值。</p>
<p>对于一个节点来说，紧密性中心性是节点到所有其他节点的最小距离和的倒数：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Closeness_Centrality.PNG" alt="Closeness Centrality" title="Closeness Centrality"></p>
<p>其中 <code>u</code> 是我们要计算紧密性中心性的节点，<code>n</code> 是网络中总的节点数，<code>d(u,v)</code> 代表节点 u 与节点 v 的最短路径距离。更常用的公式是归一化之后的中心性，即计算节点到其他节点的平均距离的倒数，你知道如何修改上面的公式吗？对了，将分子的 <code>1</code> 变成 <code>n-1</code> 即可。</p>
<p>理解公式我们就会发现，如果图是一个非连通图，那么我们将无法计算紧密性中心性。那么针对非连通图，<strong>调和中心性（Harmonic Centrality）</strong>被提了出来（当然它也有归一化的版本，你猜这次n-1应该加在哪里？）：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Harmonic_Centrality.png" alt="Harmonic Centrality" title="Harmonic Centrality"></p>
<p><strong>Wasserman and Faust</strong> 提出过另一种计算紧密性中心性的公式，专门用于包含多个子图并且子图间不相连接的非连通图：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Wasserman_and_Faust_Closeness.png" alt="Wasserman and Faust Closeness" title="Wasserman and Faust Closeness"></p>
<p>其中，<code>N</code> 是图中总的节点数量，<code>n</code> 是一个部件（component）中的节点数量。</p>
<p>当我们希望关注网络中传播信息最快的节点，我们就可以使用紧密性中心性。</p>
<h3 id="Betweenness-Centrality"><a href="#Betweenness-Centrality" class="headerlink" title="Betweenness Centrality"></a>Betweenness Centrality</h3><p>中介中心性（Betweenness Centrality）是一种检测节点对图中信息或资源流的影响程度的方法。它通常用于寻找连接图的两个部分的桥梁节点。因为很多时候，一个系统最重要的 “齿轮” 不是那些状态最好的，而是一些看似不起眼的 “媒介”，它们掌握着资源或者信息的流动性。</p>
<p>中间中心性算法首先计算连接图中每对节点之间的最短（最小权重和）路径。每个节点都会根据这些通过节点的最短路径的数量得到一个分数。节点所在的路径越短，其得分越高。计算公式：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Betweenness_Centrality_Formula.png" alt="Betweenness Centrality Formula" title="Betweenness Centrality Formula"></p>
<p>其中，<code>p</code> 是节点 s 与 t 之间最短路径的数量，<code>p(u)</code> 是其中经过节点 u 的数量。下图给出了对于节点 D 的计算过程：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Betweenness_Centrality.png" alt="Betweenness Centrality Formula" title="Betweenness Centrality"></p>
<p>当然，在一张大图上计算中介中心性是十分昂贵的。所以我们需要更快的，成本更小的，并且精度大致相同的算法来计算，例如 Randomized-Approximate Brandes。我们不会对这个算法继续深入，感兴趣的话，可以去了解一下，算法如何通过随机（Random）和度的筛选（Degree）达到近似的效果。</p>
<p>中介中心性在现实的网络中有广泛的应用，我们使用它来发现瓶颈、控制点和漏洞。例如，识别不同组织的影响者，他们往往是各个组织的媒介，例如寻找电网的关键点，提高整体鲁棒性。</p>
<h3 id="PageRank"><a href="#PageRank" class="headerlink" title="PageRank"></a>PageRank</h3><p>在所有的中心性算法中，PageRank 是最著名的一个。它测量节点传递影响的能力。PageRank 不但节点的直接影响，也考虑 “邻居” 的影响力。例如，一个节点拥有一个有影响力的 “邻居”，可能比拥有很多不太有影响力的 “邻居” 更有影响力。PageRank 统计到节点的传入关系的数量和质量，从而决定该节点的重要性。</p>
<p>PageRank 算法以谷歌联合创始人拉里·佩奇的名字命名，他创建了这个算法来对谷歌搜索结果中的网站进行排名。不同的网页之间相互引用，网页作为节点，引用关系作为边，就可以组成一个网络。被更多网页引用的网页，应该拥有更高的权重；被更高权重引用的网页，也应该拥有更高权重。原始公式：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/PageRank_Formula.png" alt="PageRank Formula" title="PageRank Formula"></p>
<p>其中，<code>u</code> 是我们想要计算 PageRank 的网页，<code>T1</code> 到 <code>Tn</code> 是引用的网页。<code>d</code> 被称为阻尼系数（damping factor），代表一个用户继续点击网页的概率，一般被设置为 0.85，范围 0~1。<code>C(T)</code> 是节点 T 的出度。</p>
<p>从理解上来说，PageRank 算法假设一个用户在访问网页时，用户可能随机输入一个网址，也可能通过一些网页的链接访问到别的网页。那么阻尼系数代表用户对当前网页感到无聊，随机选择一个链接访问到新的网页的概率。那么 PageRank 的数值代表这个网页通过其他网页链接过来（入度，in-degree）的可能性。那你能如何解释 PageRank 方程中的 <code>1-d</code> 呢？实际，<code>1-d</code> 代表不通过链接访问，而是随机输入网址访问到网页的概率。</p>
<p>PageRank 算法采用迭代方式计算，直到结果收敛或者达到迭代上限。每次迭代都会分两步更新节点权重和边的权重，详细如下图：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/PageRank_Iteration.png" alt="PageRank Iteration" title="PageRank Iteration"></p>
<p>当然，上图的计算并没有考虑阻尼系数，那为什么一定要阻尼系数呢？除了我们定义的链接访问概率，有没有别的意义呢？从上图的过程中，我们可能会发现一个问题，如果一个节点（或者一组节点），只有边进入，却没有边出去，会怎么样呢？按照上图的迭代，节点会不断抢占 PageRank 分数。这个现象被称为 <strong>Rank Sink</strong>，如下图：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Rank_Sink.png" alt="Rank Sink" title="Rank Sink"></p>
<p>解决 Rank Sink 的方法有两个。第一个，假设这些节点有隐形的边连向了所有的节点，遍历这些隐形的边的过程称为 teleportation。第二个，使用阻尼系数，如果我们设置 <code>d</code> 等于 0.85，我们仍然有 0.15 的概率从这些节点再跳跃出去。</p>
<p>尽管阻尼系数的建议值为 0.85，我们仍然可以根据实际需要进行修改。调低阻尼系数，意味着访问网页时，更不可能不断点击链接访问下去，而是更多地随机访问别的网页。那么一个网页的 PageRank 分数会更多地分给他的直接下游网页，而不是下游的下游网页。</p>
<p>PageRank 算法已经不仅限于网页排名。例如：</p>
<ul>
<li>寻找最重要的基因：我们要寻找的基因可能不是与生物功能联系最多的基因，而是与最重要功能有紧密联系的基因；</li>
<li>who to follow service at twitter：Twitter使用个性化的 PageRank 算法（Personalized PageRank，简称 PPR）向用户推荐他们可能希望关注的其他帐户。该算法通过兴趣和其他的关系连接，为用户展示感兴趣的其他用户；</li>
<li>交通流量预测：使用 PageRank 算法计算人们在每条街道上停车或结束行程的可能性；</li>
<li>反欺诈：医疗或者保险行业存在异常或者欺诈行为，PageRank 可以作为后续机器学习算法的输入。</li>
</ul>
<h2 id="社群发现算法"><a href="#社群发现算法" class="headerlink" title="社群发现算法"></a>社群发现算法</h2><p>社群的形成在各种类型的网络中都很常见。识别社群对于评估群体行为或突发事件至关重要。对于一个社群来说，内部节点与内部节点的关系（边）比社群外部节点的关系更多。识别这些社群可以揭示节点的分群，找到孤立的社群，发现整体网络结构关系。社群发现算法（Community Detection Algorithms）有助于发现社群中群体行为或者偏好，寻找嵌套关系，或者成为其他分析的前序步骤。社群发现算法也常用于网络可视化。</p>
<p>下图是社群发现算法的分类。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Community_Detection_Algorithms.png" alt="Community Detection Algorithms" title="Community Detection Algorithms"></p>
<h3 id="Measuring-Algorithm"><a href="#Measuring-Algorithm" class="headerlink" title="Measuring Algorithm"></a>Measuring Algorithm</h3><p>三角计数（Triangle Count）和聚类系数（Clustering Coefficient）经常被一起使用。<strong>三角计数</strong>计算图中由节点组成的三角形的数量，要求任意两个节点间有边（关系）连接。<strong>聚类系数</strong>算法的目标是测量一个组的聚类紧密程度。该算法计算网络中三角形的数量，与可能的关系的比率。聚类系数为 1 表示这个组内任意两个节点之间有边相连。</p>
<p>有两种聚类系数：局部聚类系数（Local Clustering Coefficient）和全局聚类系数（Global Clustering Coefficient）。</p>
<p><strong>局部聚类系数</strong>计算一个节点的邻居之间的紧密程度，计算时需要三角计数。计算公式：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Clustering_Coefficient_Formula.png" alt="Clustering Coefficient Formula" title="Clustering Coefficient Formula"></p>
<p>其中，<code>u</code> 代表我们需要计算聚类系数的节点，<code>R(u)</code> 代表经过节点 <code>u</code> 和它的邻居的三角形个数，<code>k(u)</code> 代表节点 <code>u</code> 的度。下图是三三角计数聚类系数计算示意图：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Triangle_Count_and_Clustering_Coefficient_for_Node_u.png" alt="Triangle Count and Clustering Coefficient for Node u" title="Triangle Count and Clustering Coefficient for Node u"></p>
<p><strong>全局聚类系数</strong>是局部聚类系数的归一化求和。</p>
<p>当需要计算一个组的稳定性或者聚类系数时，我们可以使用三角计数。三角计数在社交网络分析中有广泛的应用，通航被用来检测社区。聚类系数可以快速评估特定组或整个网络的内聚性。这些算法可以共同用于特定网络结构的寻找。例如，探索网页的主题结构，基于网页之间的相互联系，检测拥有共同主题的 “网页社群”。</p>
<h3 id="Components-Algorithm"><a href="#Components-Algorithm" class="headerlink" title="Components Algorithm"></a>Components Algorithm</h3><p><strong>强关联部件（Strongly Connected Components，简称 SCC）</strong>算法寻找有向图内的一组一组节点，每组节点可以通过关系 <em>互相</em> 访问。在 “Community Detection Algorithms” 的图中，我们可以发现，每组节点内部不需要直接相连，只要通过路径访问即可。</p>
<p><strong>关联部件（Connected Components）</strong>算法，不同于 SCC，组内的节点对只需通过一个方向访问即可。</p>
<p>关联类算法作为图分析的早期算法，用以了解图的结构，或确定可能需要独立调查的紧密集群十分有效。对于推荐引擎等应用程序，也可以用来描述组中的类似行为等等。许多时候，算法被用于查找集群并将其折叠成单个节点，以便进一步进行集群间分析。对于我们来说，先运行以下关联类算法查看图是否连通，是一个很好的习惯。</p>
<h3 id="Label-Propagation-Algorithm"><a href="#Label-Propagation-Algorithm" class="headerlink" title="Label Propagation Algorithm"></a>Label Propagation Algorithm</h3><p>标签传播算法（Label Propagation Algorithm，简称 LPA）是一个在图中快速发现社群的算法。在 LPA 算法中，节点的标签完全由它的直接邻居决定。算法非常适合于半监督学习，你可以使用已有标签的节点来种子化传播进程。</p>
<p>LPA 是一个较新的算法，由 Raghavan 等人于 2007 年提出。我们可以很形象地理解算法的传播过程，当标签在紧密联系的区域，传播非常快，但到了稀疏连接的区域，传播速度就会下降。当出现一个节点属于多个社群时，算法会使用该节点邻居的标签与权重，决定最终的标签。传播结束后，拥有同样标签的节点被视为在同一群组中。</p>
<p>下图展示了算法的两个变种：Push 和 Pull。其中 Pull 算法更为典型，并且可以很好地并行计算：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Label_Propagation_Push_and_Pull.png" alt="Label Propagation Push and Pull" title="Label Propagation Push and Pull"></p>
<p>我们不再继续深入，看完上图，你应该已经理解了算法的大概过程。其实，做过图像处理的人很容易明白，所谓的标签传播算法，不过是图像分割算法的变种，Push 算法是区域生长法（Region Growing）的简化版，而 Pull 更像是分割和合并（divide-and-merge，也有人称 split-merge）算法。确实，图像（image）的像素和图（graph）的节点是十分类似的。</p>
<h3 id="Louvain-Modularity-Algorithm"><a href="#Louvain-Modularity-Algorithm" class="headerlink" title="Louvain Modularity Algorithm"></a>Louvain Modularity Algorithm</h3><p>Louvain Modularity 算法在给节点分配社群是，会比较社群的密度，而不仅仅是比较节点与社群的紧密程度。算法通过查看节点与社群内关系的密度与平均关系密度的比较，来量化地决定一个节点是否属于社群。算法不但可以发现社群，更可以给出不同尺度不同规模的社群层次，对于理解不同粒度界别的网络结构有极大的帮助。</p>
<p>算法在 2008 年被提出以后，迅速成为了最快的模块化算法之一。算法的细节很多，我们无法一一覆盖，下图给出了一个粗略的步骤，帮助我们理解算法如何能够多尺度地构建社群：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190504%20Introduction%20to%20Graph%20Algorithms/Louvain_Algorithm_Process.png" alt="Louvain Algorithm Process" title="Louvain Algorithm Process"></p>
<p>Louvain Modularity 算法非常适合庞大网络的社群发现，算法采用启发式方式从而能够克服传统 Modularity 类算法的局限。算法应用：</p>
<ul>
<li>检测网络攻击:该算可以应用于大规模网络安全领域中的快速社群发现。一旦这些社群被发现，就可以用来预防网络攻击；</li>
<li>主题建模：从 Twitter 和 YouTube 等在线社交平台中提取主题，基于文档中共同出现的术语，作为主题建模过程的一部分；</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文更像是一篇综述，算法很干，我们会在后续继续分享图分析相关内容，敬请期待。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jerryroc.github.io/2019/04/21/Introduction-to-Graph-Database/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="GuPeng">
      <meta itemprop="description" content="Everything About Data Science.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Peng's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/21/Introduction-to-Graph-Database/" class="post-title-link" itemprop="url">图数据库：概览</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-21 20:55:51" itemprop="dateCreated datePublished" datetime="2019-04-21T20:55:51+08:00">2019-04-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-05-21 17:59:10" itemprop="dateModified" datetime="2019-05-21T17:59:10+08:00">2019-05-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Yes-NoSQL/" itemprop="url" rel="index"><span itemprop="name">Yes&NoSQL</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从-Yes-amp-NoSQL-说起"><a href="#从-Yes-amp-NoSQL-说起" class="headerlink" title="从 Yes&amp;NoSQL 说起"></a>从 Yes&amp;NoSQL 说起</h1><p>在文章开始之前，先解释下为什么文章标签是 “Yes&amp;NoSQL”。不同于传统的关系型数据库，NoSQL 是 “not only SQL” 的缩写，特指不以 SQL 为中心的任何非关系型数据库。比较常见的错误是，把 “NoSQL” 理解为 “NO SQL”，所以使用 “Yes&amp;NoSQL” 代表关系型及非关系型数据库，关注所有数据库知识。</p>
<p>NoSQL 包含图数据库 (Graph DBMS)，时间序列数据库(Time Series DBMS)，宽列存储(Wide Column Stores，也称基于 Big Table 的存储)等等。典型的 NoSQL 数据库比如 Redis，MongoDB，HBase等等。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190421%20Introduction%20to%20Graph%20Database/popularity_changes_per_db_cate_201904.png" alt="popularity changes per db category 201904"></p>
<p>本期，我们关注图数据库。图数据库，<strong>不是存储图片的数据库</strong>，而是存储节点与他们之间关系的数据库。根据<a href="https://db-engines.com/en/ranking_categories" target="_blank" rel="noopener">DB-Engines</a>数据显示，图数据库是近五年来成长最快的数据库分类。 由于很早开始被Twitter，Facebook和Google在内的公司采用，图已经演变成当今各行各业所使用的主流技术。</p>
<h1 id="什么是图"><a href="#什么是图" class="headerlink" title="什么是图"></a>什么是图</h1><p>图广泛存在于现实世界之中，从社交网络到金融关系，都会涉及大量的高度关联数据。这些数据构成了庞大的图，图数据库就是呈现和查询这些关联的做好的方式。</p>
<p>图，形式上是<strong>节点</strong> (vertex，或者 node) 和<strong>边</strong> (edge) 的集合。在一张图中，一个节点代表一个实体，例如某个人，某个城市，某家公司等等。边，就是关联这些节点的关系 (relation) ，例如“王健林”是“王思聪”的父亲，“我”生活在“上海”。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190421%20Introduction%20to%20Graph%20Database/graph_of_the_gods.png" alt="Graph of the gods"></p>
<p>如图，JanusGraph <a href="https://docs.janusgraph.org/latest/getting-started.html" target="_blank" rel="noopener">官网教程</a>中给了一个希腊神话的人物及罗马神殿关系图，是一个典型的带标签的属性图 （Labeled-Property Graph）。</p>
<p>我们可以从图中容易发现：</p>
<ul>
<li>赫拉克勒斯（Hercules）的父亲是丘比特（Jupiter，对应希腊神话中的宙斯），母亲是阿尔克墨涅（Alcmene）；</li>
<li>阿尔克墨涅（Alcmene）是一个凡人（human），所以赫拉克勒斯（Hercules）是一个半神（demigod）；</li>
<li>尼普顿（Neptune，海神）住在海洋中，因为喜欢海浪的声音。</li>
<li>……</li>
</ul>
<p>然后我们就很容易理解以下概念：</p>
<ul>
<li>节点拥有一个（也可以是多个）标签（label），例如神（god）、半神（demigod）、凡人（human）等等；</li>
<li>节点可以拥有很多属性（property），例如姓名、年龄等等，以键值对（key-value pair）的形式表示，并且属性值也可以是键值对；</li>
<li>边也有标签，标签可以是“住在”、“是他的父亲”等等；</li>
<li>边有方向，不同图数据库对方向的约束可能不一样，例如JanusGraph只接受单向边，如果需要表达双向关系，则需要再添加一条反向的边；</li>
<li>边也有属性，例如某人“住在”某地的关系上存在“原因”的属性；</li>
</ul>
<p>当然，实际场景中的图要比上图复杂的多的多，图数据库就是处理这种数据的工具。</p>
<h1 id="为什么需要图数据库"><a href="#为什么需要图数据库" class="headerlink" title="为什么需要图数据库"></a>为什么需要图数据库</h1><p>其实这个问题可以这么问：为什么传统关系型数据库不能很好处理图？</p>
<p>有人曾做过一个测试：在一个包含100w人，每人约有50个朋友的社交网络中找到最大深度为5的朋友的朋友。下图为图数据库Neo4J和关系型数据库在寻找扩展朋友时的性能对比。</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190421%20Introduction%20to%20Graph%20Database/Neo4j_vs_Relation_DBMS.jpg" alt="Neo4j vs Relation DBMS"></p>
<p>从图中可以发现，当我们需要寻找朋友的朋友（深度为 2）时，关系型数据库（RDBMS）与 Neo4j 性能差距并不明显；深度为 4 时，关系型数据库需要近半个小时才能返回结果；当深度到达 5 时，关系型数据库已无法返回结果。从中我们可以很容易看出，对于图数据库来说，数据量越大，查询需要涉及的关系越复杂，图数据库的性能优势越大。</p>
<h2 id="为什么关系型数据库不行"><a href="#为什么关系型数据库不行" class="headerlink" title="为什么关系型数据库不行"></a>为什么关系型数据库不行</h2><p>我们来复盘一下上面的实验。对于关系型数据库来说，朋友的朋友意味着两张表的 join， 会很容易产生笛卡尔积的中间数据，数据量随着深度呈幂增长。这就是为什么性能随着查询深度，下降如此之快。</p>
<p>再举一个例子，假设刚才我们在寻找“ A 的朋友是谁”，我们的数据表针对此类查询进行了特殊表设计，查询一般会比较快。但是，如果我们需要查询“谁的朋友是 A ”，我们可能需要遍历整个关系表，查询效率就会瞬间降低。</p>
<p>同样的，在商品数据库中，我们查询某个客户买了哪些商品通常效率比较高，但是我们要查询”那些客户买了这个商品”甚至是“有哪些买了这个商品的客户也买了那个商品”的这种多层关系的时候，关系型数据库通常就显得力不从心了。实际上，关系型数据库在处理反向查询以及多层次关系查询的时候通常开销较大。</p>
<h2 id="为什么图数据库可以"><a href="#为什么图数据库可以" class="headerlink" title="为什么图数据库可以"></a>为什么图数据库可以</h2><p>原理上的解释，看完下个章节，可能你就会有答案。这里，先介绍下图数据库的特点：</p>
<ol>
<li><p>使用图的方式表达现实世界很多事物更为直接、易于理解，自然也易于建模。你可以喜欢一部电影，也可以和好朋友建立密切的关系，也可以创作一些文章，均可以用节点和边的方式表达；</p>
</li>
<li><p>图数据库可以高效插入大量数据。从应用的角度来说，知识图谱、社交关系、风控关系等，数据量在亿级别。图数据库在十亿级别的数据量时，能保持较好的性能；</p>
</li>
<li><p>图数据库可以高效进行关联查询、数据插入，并且提供了针对图查询的语言。我们已在上一小结说明，关系型数据库针对关联查询效率下降严重。图数据库通过针对性的优化，在数据建模，存储形式上支持高效的关联查询。图模型提供了固有的索引数据结构，因此它不需要为给定条件的查询加载或接触不相关的数据。目前比较主流的图查询语言是 Gremlin 和 Cypher，都可以用模式匹配的方式，去寻找图上的路径。例如，使用 JanusGraph 寻找我的 2 度朋友关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V().has(&apos;name&apos;,&apos;gupeng&apos;).out(&apos;friend&apos;).out(&apos;friend&apos;)</span><br></pre></td></tr></table></figure>
<p>使用 Cypher 寻找我和我的好朋友的共同好友：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (a:Person &#123;name:&apos;gupeng&apos;&#125;) -[:KNOWS]-&gt; (b) -[:KNOWS]-&gt; (c)</span><br><span class="line">(a) -[:KNOWS]-&gt; (c)</span><br><span class="line">RETURN b,c</span><br></pre></td></tr></table></figure>
<p>并且，在查询节点之间的关系通常可以做到常数级别。</p>
</li>
<li><p>图数据库提供专业的分析算法或者工具。分析算法例如 PageRank、ShortestPath 等等。大部分图数据库也会提供可视化的图显示，使得查询和分析十分直观。</p>
</li>
</ol>
<h2 id="图数据库应用"><a href="#图数据库应用" class="headerlink" title="图数据库应用"></a>图数据库应用</h2><p>图数据库拥有广泛的适用场景，因为实体和关系的建模方式能很好地抽象自然和社会的很多事物。下面举例最常使用的场景。</p>
<ol>
<li><p>社交网络</p>
<p>在社交网络中使用图数据库可以方便得识别人/群组和他们交流的事物之间的直接或间接的联系，使用户能够高效地对其他人或事物进行打分、评论、发现彼此存在的关系和共同关系的事情。可以更加直观得了解社交网络中人与人之间如何互动、如何关联、如何以群组的形式来做事情或选择。</p>
</li>
<li><p>实时推荐</p>
<p>推荐算法通过用户的购买、生产、消费、打分或评论等行为，建立人和商品之间的联系。推荐算法可以识别出某些资源会吸引特定个人或群体，或者某些个人或群体可能对特定资源感兴趣。用图数据库存储和查询这些数据使得应用程序可以为最终用户呈现实时结果，反映数据最新的变化，进行实时的商品推荐。</p>
</li>
<li><p>知识图谱</p>
<p>最早起源于Google Knowledge Graph。知识图谱本质上是一种语义网络 。其结点代表实体（entity）或者概念（concept），边代表实体/概念之间的各种语义关系。所以知识图谱可以很好地用图来表达。建立知识图谱，可以为后续应用提供基础，例如问答系统，商品推荐，信息检索等等。</p>
</li>
<li><p>反欺诈和风控</p>
<p>例如，近年来的消费金融行业快速发展，相比于传统商业银行，拥有自己独特的优势：填写字段少、在线操作、审核速度快、放贷及时。这类申请人群通常因缺乏征信信息而给消费金融企业带来了巨大的信用和欺诈风险。而图分析结合传统机器学习算法，可以在有限信用记录甚至是“零”信用记录下进行更准确的风险控制和欺诈识别。</p>
</li>
</ol>
<p>此外，图数据库产品还广泛用在地理空间和物流应用，路由计算，电商和社交类产品防机器人作弊，网络和数据中心管理，授权和访问控制等领域。</p>
<h1 id="数据模型-amp-图计算引擎"><a href="#数据模型-amp-图计算引擎" class="headerlink" title="数据模型 &amp; 图计算引擎"></a>数据模型 &amp; 图计算引擎</h1><p>我们从使用图数据库的角度入手，一个完善的图数据系统至少应该包括图存储和查询，图处理和计算，数据导入导出，可能还有可视化，对于商业化产品还需要高可用及容灾备份。下面对主要部分进行介绍。</p>
<h2 id="图存储-amp-数据模型"><a href="#图存储-amp-数据模型" class="headerlink" title="图存储 &amp; 数据模型"></a>图存储 &amp; 数据模型</h2><p>图数据如何存储图，对存储效率和查询效率都至关重要。我们称数据库表达数据的方式为图模型（Data Model），是一种对图的建模方式。</p>
<p>目前使用的图模型有3种，分别是属性图（Property Graph）、资源描述框架（RDF，Resource Description Framework）和超图（HyperGraph）。</p>
<ol>
<li><p><strong>属性图（Property Graph）</strong>：目前主流图数据库选择的数据模型，更确切的说是带标签的属性图（Labeled-Property Graph）。除了图所共有节点和边的概念，我们已经在上面介绍了属性和标签的概念。我们可以用一个属性图来表达属性图各元素的关系：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190421%20Introduction%20to%20Graph%20Database/graph_of_property_graph_model.jpg" alt="graph of property graph model"></p>
</li>
<li><p><strong>资源描述框架（RDF，Resource Description Framework）</strong>：在一个 RDF 中，增加的信息都以单独的节点表示。RDF由节点和边组成，节点表示实体/资源或者属性，边则表示了实体和实体之间的关系以及实体和属性的关系。相较于属性图，对属性的处理方式不一样。例如，如果要为某个”人“节点增加”name“属性，对于属性图来说，在这个”人“的”name“属性上设置名字，而在 RDF 中，直接通过一条”hasName“的边指向了设置名字。RDF 形式上表示为SPO（Subject - Predicte - Object）三元组，有时候也称为一条语句（Statement）。RDF 比较多地被使用在知识图谱中，那我们也通常称一条语句为一条知识。许多图数据库是基于RDF实现的，包括：AllegroGraph，Virtuoso，Blazegraph和Stardog。</p>
</li>
<li><p><strong>超图（HyperGraph）</strong>：不同于属性图和 RDF，超图的边可以连接任意数量（不能为 0）的节点，超图的边又称为超边（hyperedges）。如图是一个典型的超图：</p>
<p><img src="https://github.com/JerryRoc/graphs/raw/master/20190421%20Introduction%20to%20Graph%20Database/Hypergraph_example.png" alt="Hypergraph example"></p>
</li>
</ol>
<p>主流的开源图数据库 Neo4j 和 JanusGraph 都采用属性图的数据模型。不同的是，Neo4j 使用原生图存储，JanusGraph 使用非原生图存储，将图结构序列化存储到基于 BigTable Model 的数据库（例如 Cassandra，HBase）中。原生图存储为存储和使用图做了更多的优化，遍历查询性能更高，但非遍历类的查询则不占优势，且为了全局搜索还会占用大量内存。</p>
<h2 id="图查询和图计算-OLTP-和-OLAP"><a href="#图查询和图计算-OLTP-和-OLAP" class="headerlink" title="图查询和图计算 / OLTP 和 OLAP"></a>图查询和图计算 / OLTP 和 OLAP</h2><p>图查询和图计算都是对图的遍历。图数据库主要提供两种与遍历图的方式：OLTP （Online Transaction Processing）和 OLAP （Online Analytical Processing）。</p>
<blockquote>
<ul>
<li>OLTP：实时返回，涉及少量数据，随机的数据访问，串行运行，用于查询，偏向深度优先的计算引擎，不需要太大的内存；</li>
<li>OLAP：长时间运行，涉及几乎整个图，串行地访问数据，并行运行，批量处理，偏向广度优先的计算引擎，需要更大的内存。</li>
</ul>
</blockquote>
<p>图查询指支持对图数据模型的增、删、改、查（CRUD）方法，更关注 OLTP。<strong>有的图数据库也继承了少量的图计算能力，但真正的大型系统还是需要单独的计算框架</strong>。</p>
<p>图计算引擎技术，偏重于全局查询，通常都对与批处理大规模数据做过优化。只有一部分图计算引擎有自己的存储层，其他的都只关注与如果处理外部传入的数据，然后返回结果到其他地方保存。图计算引擎，或者说图的并行计算框架，包括 Google 的 Pregel，基于 Spark 的 GraphX，Apache 下的 Giraph / HAMA 以及 GraphLab，其中Giraph 是 Pregel 的开源实现。</p>
<h1 id="图数据库产品"><a href="#图数据库产品" class="headerlink" title="图数据库产品"></a>图数据库产品</h1><h2 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h2><p>Neo4j 是老牌的图数据代表（2007）。其功能强大，性能也不错，单节点的服务器可承载上亿级的节点和关系，单节点性能不够时也可进行分布式集群部署。</p>
<p>Neo4j有自己的后端存储，不必如同 JanusGraph 等一样依赖另外的数据库存储。Neo4j 在每个节点中存储了每个边的指针，因而遍历时效率相当高。Neo4j分为社区版和企业版，社区版功能受限，另外其提供可视化的客户端感觉很不错。</p>
<p>据neo4j的中国合作方的社区中描述，主要区别如下：</p>
<p>1、容量：社区版最多支持 320 亿个节点、320 亿个关系和 640 亿个属性，而企业版没有这个限制；</p>
<p>2、并发：社区版只能部署成单实例，不能做集群。而企业版可以部署成高可用集群或因果集群，从而可以解决高并发量的问题；</p>
<p>3、容灾：由于企业版支持集群，部分实例出故障不会影响整个系统正常运行；</p>
<p>4、热备：社区版只支持冷备份，即需要停止服务后才能进行备份，而企业版支持热备，第一次是全量备份，后续是增量备份；</p>
<p>5、性能：社区版最多用到 4 个内核，而企业能用到全部内核，且对性能做了精心的优化；</p>
<p>6、支持：企业版客户能得到 5X10 电话支持（Neo4j 美国电话、邮件，微云数聚电话、微信、邮件）；</p>
<p>考虑到这些限制，要选开源免费大容量分布式的图数据库的可以跳过了，研究图论及小型应用或不差钱的项目则选其的支持服务则另当别论。另外 Neo4j 的协议为 GPLv3，这个也不适合选用。</p>
<h2 id="JanusGraph"><a href="#JanusGraph" class="headerlink" title="JanusGraph"></a>JanusGraph</h2><p>JanusGraph（2017） 基于 Titan（2012）发展而来，包含其所有功能，采用 Tikerpop 的 Gremlin 图查询语言，有单独的后端存储，支持 Cassandra / HBase 等做存储，支持 Solr / ElasticSearch / Lucence 等做图索引。支持Spark GraphX / Giraph等图分析计算引擎及Hadoop分布式计算框架。原生支持集成了 Tinkerpop 系列组件：Gremlin 查询语言，Gremlin-Server 及 Gremlin applications。</p>
<p>采用很友好的 Apache2.0 协议，支持对接可视化组件如 Cytoscape，Gephi plugin for Apache TinkerPop，Graphexp，KeyLines by Cambridge Intelligence，Linkurious 等。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>总体来说，图数据和图分析还处在方兴未艾的阶段，很多现有的产品都相当的“实验室”，性能提升空间十分巨大。图数据库的价值，还需要更多的开发工程师、数据分析师来实现。</p>
<p>关于图数据库的未来，引用一段知乎作者 bop 的一段话：</p>
<blockquote>
<p>图的本质难题是什么？是数据的高度关联带来的严重的随机访问。所以，传统的关系型数据库解决不了这个问题，因为他们仍然是面向磁盘优化，尽可能利用磁盘顺序读写的优势。Neo4j 这种数据结构在数据落到磁盘上的时候，随机访问比关系型数据库多更多，性能衰减想当厉害。那么分布式 NoSQL 的路子呢？网络是瓶颈。完美的最小割图分区算法是 NP 难题，而且在数据写入的情况下还要面临动态调整的难题。如果使用naive的分区算法，网络通讯的开销是想当大的。</p>
<p>所以，个人浅见，只有靠新硬件来解决问题。更廉价的大内存、NVRAM、RDMA高速网络、随机读写更强的SSD磁盘、有硬件事务支持的CPU等。</p>
</blockquote>
<p>技术世界就是这样，封装封装再封装，重构重构造新轮。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>图数据库入门概览，作者：AirCloud，<a href="https://zhuanlan.zhihu.com/p/32856981" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32856981</a></li>
<li>一起学图数据库之一：图数据库介绍，作者：王二铁，<a href="https://zhuanlan.zhihu.com/p/32857155" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32857155</a></li>
<li>一起学图数据库之三：图数据库市场格局，作者：Yu Xu，翻译：王二铁，<a href="https://zhuanlan.zhihu.com/p/33112533" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33112533</a></li>
<li>知乎答案：类似 Neo4j 这样的图数据库在国内会兴起么？，作者 javeme，<a href="https://www.zhihu.com/question/19999933/answer/550019788" target="_blank" rel="noopener">https://www.zhihu.com/question/19999933/answer/550019788</a></li>
<li>图数据库基础，作者：温正湖，<a href="https://zhuanlan.zhihu.com/p/50171330" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50171330</a></li>
<li>20180818图数据库概览，作者：朱金华，<a href="https://zhuanlan.zhihu.com/p/42351039" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42351039</a></li>
<li>知乎答案：图论数据库未来的发展方向？，作者：bop，<a href="https://www.zhihu.com/question/31819867/answer/237043857" target="_blank" rel="noopener">https://www.zhihu.com/question/31819867/answer/237043857</a></li>
<li>WIKIPEDIA Graph_database， <a href="https://en.wikipedia.org/wiki/Graph_database" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Graph_database</a></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jerryroc.github.io/2019/04/20/Hello-World/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="GuPeng">
      <meta itemprop="description" content="Everything About Data Science.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Peng's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/20/Hello-World/" class="post-title-link" itemprop="url">Hello World</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-20 21:44:44" itemprop="dateCreated datePublished" datetime="2019-04-20T21:44:44+08:00">2019-04-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-05-06 16:40:35" itemprop="dateModified" datetime="2019-05-06T16:40:35+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/index/" itemprop="url" rel="index"><span itemprop="name">index</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>欢迎来到我的博客，我来自 Teradata，是一名 Data Scientist。作为数据科学从业者，深知数据库知识、计算机知识、数据分析能力，当然还有算法知识，都是不可或缺的。</p>
<p>博客会针对这四个方面的内容，记录工作中的探索和心得。当然，我也会关注”如何快速成长为数据科学家“这一主题，提供一系列的课程，但这不会是本博客的主要内容。</p>
<h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p>所有文章将可以在此页面进行索引和跳转，新的文章也可能在此页面进行预告~</p>
<p><strong>Yes&amp;NoSQL</strong></p>
<p>主要关注数据库知识，了解㓊类型的数据是如何存储和取用的。包括但不限于传统关系型数据库的原理和使用、图片等非结构化数据如何存储、有什么好的工具提供完整的平台解决方案；</p>
<ol>
<li><a href="https://jerryroc.github.io/2019/04/21/Introduction-to-Graph-Database/">图数据库：概览</a></li>
<li>图数据库：JanusGraph 简介（TODO）</li>
</ol>
<p><strong>GeekStyle</strong></p>
<p>主要关注计算机知识，对于一个 Data Scientist 来说，我会更关注如何高效工作。包括但不限于如何选择生产工具、如何自动化建立机器学习模型、如何高效利用多台计算机建立模型；</p>
<ol>
<li>开源 AI 分布式框架 Ray （TODO）</li>
</ol>
<p><strong>AnalyzeAnything</strong></p>
<p>主要关注数据分析、数据挖掘，了解如何让数据说话，让数据真正产生价值。包括但不限于如何可视化你的数据、如何进行数学建模的过程、怎样去解决你的业务问题；</p>
<ol>
<li>可视化工具概览（TODO）</li>
</ol>
<p><strong>Algorithm</strong></p>
<p>关注算法知识，了解最前沿的算法和工具。包括但不限于算法的原理和案例、如何理解算法的超参和算的局限性。</p>
<ol>
<li><a href="https://jerryroc.github.io/2019/05/04/Introduction-to-Graph-Algorithms/">图算法：概览</a></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">GuPeng</p>
              <div class="site-description motion-element" itemprop="description">Everything About Data Science.</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/JerryRoc" title="GitHub &rarr; https://github.com/JerryRoc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GuPeng</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="Total Visitors">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="Total Views">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  




  

  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  

</body>
</html>
